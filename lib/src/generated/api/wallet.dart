// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<Mutex < lwk_wollet :: Wollet >>
@sealed
class MutexLwkWolletWollet extends RustOpaque {
  MutexLwkWolletWollet.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexLwkWolletWollet.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: LwkCore
        .instance.api.rust_arc_increment_strong_count_MutexLwkWolletWollet,
    rustArcDecrementStrongCount: LwkCore
        .instance.api.rust_arc_decrement_strong_count_MutexLwkWolletWollet,
    rustArcDecrementStrongCountPtr: LwkCore
        .instance.api.rust_arc_decrement_strong_count_MutexLwkWolletWolletPtr,
  );
}

class Wallet {
  final MutexLwkWolletWollet ptr;

  const Wallet.raw({
    required this.ptr,
  });

  Future<Address> address({required int index, dynamic hint}) =>
      LwkCore.instance.api.walletAddress(that: this, index: index, hint: hint);

  Future<Address> addressLastUnused({dynamic hint}) =>
      LwkCore.instance.api.walletAddressLastUnused(that: this, hint: hint);

  Future<List<Balance>> balances({dynamic hint}) =>
      LwkCore.instance.api.walletBalances(that: this, hint: hint);

  Future<String> blindingKey({dynamic hint}) =>
      LwkCore.instance.api.walletBlindingKey(that: this, hint: hint);

  static Future<String> broadcastTx(
          {required String electrumUrl,
          required List<int> txBytes,
          dynamic hint}) =>
      LwkCore.instance.api.walletBroadcastTx(
          electrumUrl: electrumUrl, txBytes: txBytes, hint: hint);

  Future<String> buildAssetTx(
          {required int sats,
          required String outAddress,
          required double absFee,
          required String asset,
          dynamic hint}) =>
      LwkCore.instance.api.walletBuildAssetTx(
          that: this,
          sats: sats,
          outAddress: outAddress,
          absFee: absFee,
          asset: asset,
          hint: hint);

  Future<String> buildLbtcTx(
          {required int sats,
          required String outAddress,
          required double absFee,
          dynamic hint}) =>
      LwkCore.instance.api.walletBuildLbtcTx(
          that: this,
          sats: sats,
          outAddress: outAddress,
          absFee: absFee,
          hint: hint);

  Future<PsetAmounts> decodeTx({required String pset, dynamic hint}) =>
      LwkCore.instance.api.walletDecodeTx(that: this, pset: pset, hint: hint);

  Future<String> descriptor({dynamic hint}) =>
      LwkCore.instance.api.walletDescriptor(that: this, hint: hint);

  factory Wallet(
          {required Network network,
          required String dbpath,
          required DescriptorBase descriptor,
          dynamic hint}) =>
      LwkCore.instance.api.walletNew(
          network: network, dbpath: dbpath, descriptor: descriptor, hint: hint);

  Future<Uint8List> signTx(
          {required Network network,
          required String pset,
          required String mnemonic,
          dynamic hint}) =>
      LwkCore.instance.api.walletSignTx(
          that: this,
          network: network,
          pset: pset,
          mnemonic: mnemonic,
          hint: hint);

  Future<void> sync({required String electrumUrl, dynamic hint}) =>
      LwkCore.instance.api
          .walletSync(that: this, electrumUrl: electrumUrl, hint: hint);

  Future<List<Tx>> txs({dynamic hint}) =>
      LwkCore.instance.api.walletTxs(that: this, hint: hint);

  Future<List<TxOut>> utxos({dynamic hint}) =>
      LwkCore.instance.api.walletUtxos(that: this, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Wallet && runtimeType == other.runtimeType && ptr == other.ptr;
}
