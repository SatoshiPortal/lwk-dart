// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AssetIdBTreeMapInt`, `AssetIdBTreeMapUInt`, `AssetIdHashMapInt`, `AssetIdHashMapUInt`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `into`, `try_from`

/// Address class which contains both standard and confidential addresses with the address index in the wallet
class Address {
  final String standard;
  final String confidential;
  final int? index;
  final String? blindingKey;

  const Address({
    required this.standard,
    required this.confidential,
    this.index,
    this.blindingKey,
  });

  /// Create an address from a scriptpubkey. Always returns 0 as the index is only for wallet generated addresses
  static Future<Address> addressFromScript(
          {required Network network,
          required String script,
          String? blindingKey}) =>
      LwkCore.instance.api.crateApiTypesAddressAddressFromScript(
          network: network, script: script, blindingKey: blindingKey);

  /// Validate the address string and return the network
  static Future<Network> validate({required String addressString}) =>
      LwkCore.instance.api
          .crateApiTypesAddressValidate(addressString: addressString);

  @override
  int get hashCode =>
      standard.hashCode ^
      confidential.hashCode ^
      index.hashCode ^
      blindingKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Address &&
          runtimeType == other.runtimeType &&
          standard == other.standard &&
          confidential == other.confidential &&
          index == other.index &&
          blindingKey == other.blindingKey;
}

/// Balance represents a balance of a specific asset
class Balance {
  final String assetId;
  final PlatformInt64 value;

  const Balance({
    required this.assetId,
    required this.value,
  });

  @override
  int get hashCode => assetId.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Balance &&
          runtimeType == other.runtimeType &&
          assetId == other.assetId &&
          value == other.value;
}

enum Network {
  mainnet,
  testnet,
  ;
}

class OutPoint {
  final String txid;
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

class PayjoinTx {
  /// Partially signed transaction
  final String pset;

  /// Network fee
  final BigInt networkFee;

  /// Asset fee amount paid to the server
  final BigInt assetFee;

  const PayjoinTx({
    required this.pset,
    required this.networkFee,
    required this.assetFee,
  });

  @override
  int get hashCode => pset.hashCode ^ networkFee.hashCode ^ assetFee.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PayjoinTx &&
          runtimeType == other.runtimeType &&
          pset == other.pset &&
          networkFee == other.networkFee &&
          assetFee == other.assetFee;
}

/// Decoded PSET amounts
class PsetAmounts {
  final BigInt absoluteFees;
  final List<Balance> balances;

  const PsetAmounts({
    required this.absoluteFees,
    required this.balances,
  });

  @override
  int get hashCode => absoluteFees.hashCode ^ balances.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PsetAmounts &&
          runtimeType == other.runtimeType &&
          absoluteFees == other.absoluteFees &&
          balances == other.balances;
}

class SizeAndFees {
  final BigInt discountedVsize;
  final BigInt discountedWeight;
  final List<Balance> absoluteFees;

  const SizeAndFees({
    required this.discountedVsize,
    required this.discountedWeight,
    required this.absoluteFees,
  });

  @override
  int get hashCode =>
      discountedVsize.hashCode ^
      discountedWeight.hashCode ^
      absoluteFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SizeAndFees &&
          runtimeType == other.runtimeType &&
          discountedVsize == other.discountedVsize &&
          discountedWeight == other.discountedWeight &&
          absoluteFees == other.absoluteFees;
}

/// Transaction object returned by getTransactions.
class Tx {
  final int? timestamp;
  final String kind;
  final List<Balance> balances;
  final String txid;
  final List<TxOut> outputs;
  final List<TxOut> inputs;
  final BigInt fee;
  final int? height;
  final String unblindedUrl;
  final BigInt vsize;

  const Tx({
    this.timestamp,
    required this.kind,
    required this.balances,
    required this.txid,
    required this.outputs,
    required this.inputs,
    required this.fee,
    this.height,
    required this.unblindedUrl,
    required this.vsize,
  });

  @override
  int get hashCode =>
      timestamp.hashCode ^
      kind.hashCode ^
      balances.hashCode ^
      txid.hashCode ^
      outputs.hashCode ^
      inputs.hashCode ^
      fee.hashCode ^
      height.hashCode ^
      unblindedUrl.hashCode ^
      vsize.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Tx &&
          runtimeType == other.runtimeType &&
          timestamp == other.timestamp &&
          kind == other.kind &&
          balances == other.balances &&
          txid == other.txid &&
          outputs == other.outputs &&
          inputs == other.inputs &&
          fee == other.fee &&
          height == other.height &&
          unblindedUrl == other.unblindedUrl &&
          vsize == other.vsize;
}

class TxOut {
  final String scriptPubkey;
  final OutPoint outpoint;
  final int? height;
  final TxOutSecrets unblinded;
  final bool isSpent;
  final Address address;

  const TxOut({
    required this.scriptPubkey,
    required this.outpoint,
    this.height,
    required this.unblinded,
    required this.isSpent,
    required this.address,
  });

  @override
  int get hashCode =>
      scriptPubkey.hashCode ^
      outpoint.hashCode ^
      height.hashCode ^
      unblinded.hashCode ^
      isSpent.hashCode ^
      address.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          scriptPubkey == other.scriptPubkey &&
          outpoint == other.outpoint &&
          height == other.height &&
          unblinded == other.unblinded &&
          isSpent == other.isSpent &&
          address == other.address;
}

class TxOutSecrets {
  final BigInt value;
  final String valueBf;
  final String asset;
  final String assetBf;

  const TxOutSecrets({
    required this.value,
    required this.valueBf,
    required this.asset,
    required this.assetBf,
  });

  @override
  int get hashCode =>
      value.hashCode ^ valueBf.hashCode ^ asset.hashCode ^ assetBf.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOutSecrets &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          valueBf == other.valueBf &&
          asset == other.asset &&
          assetBf == other.assetBf;
}
