// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::wallet::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 503041023;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__types__address_address_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    network: impl CstDecode<crate::api::types::Network>,
    script: impl CstDecode<String>,
    blinding_key: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_address_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_network = network.cst_decode();
            let api_script = script.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::types::Address::address_from_script(
                        api_network,
                        api_script,
                        api_blinding_key,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__address_validate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address_string: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_validate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address_string = address_string.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::types::Address::validate(api_address_string)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__blockchain_test_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::blockchain::Blockchain>,
    electrum_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "blockchain_test",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok =
                        crate::api::blockchain::Blockchain::test(&api_that, api_electrum_url)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__broadcast_signed_pset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    electrum_url: impl CstDecode<String>,
    signed_pset: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "broadcast_signed_pset",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_electrum_url = electrum_url.cst_decode();
            let api_signed_pset = signed_pset.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::blockchain::broadcast_signed_pset(
                        api_electrum_url,
                        api_signed_pset,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__blockchain__broadcast_tx_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    electrum_url: impl CstDecode<String>,
    tx_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "broadcast_tx_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_electrum_url = electrum_url.cst_decode();
            let api_tx_bytes = tx_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok =
                        crate::api::blockchain::broadcast_tx_bytes(api_electrum_url, api_tx_bytes)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__descriptor__descriptor_new_confidential_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    network: impl CstDecode<crate::api::types::Network>,
    mnemonic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "descriptor_new_confidential",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_network = network.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::descriptor::Descriptor::new_confidential(
                        api_network,
                        api_mnemonic,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__transaction__extract_tx_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    pset: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "extract_tx_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_pset = pset.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::transaction::extract_tx_bytes(api_pset)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    index: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_index = index.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::address(&api_that, api_index)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_address_last_unused_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_address_last_unused",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::address_last_unused(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::balances(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_blinding_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_blinding_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::blinding_key(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_build_asset_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    sats: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    fee_rate: impl CstDecode<f32>,
    asset: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_build_asset_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sats = sats.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_asset = asset.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::build_asset_tx(
                        &api_that,
                        api_sats,
                        api_out_address,
                        api_fee_rate,
                        api_asset,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_build_lbtc_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    sats: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    fee_rate: impl CstDecode<f32>,
    drain: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_build_lbtc_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sats = sats.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_fee_rate = fee_rate.cst_decode();
            let api_drain = drain.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::build_lbtc_tx(
                        &api_that,
                        api_sats,
                        api_out_address,
                        api_fee_rate,
                        api_drain,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_build_payjoin_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    sats: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    asset: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_build_payjoin_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_sats = sats.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_asset = asset.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::build_payjoin_tx(
                        &api_that,
                        api_sats,
                        api_out_address,
                        api_asset,
                        api_network,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_decode_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    pset: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_decode_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_pset = pset.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::decode_tx(&api_that, api_pset)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_descriptor_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_descriptor",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::descriptor(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_init_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    network: impl CstDecode<crate::api::types::Network>,
    dbpath: impl CstDecode<String>,
    descriptor: impl CstDecode<crate::api::descriptor::Descriptor>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_init",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_network = network.cst_decode();
            let api_dbpath = dbpath.cst_decode();
            let api_descriptor = descriptor.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok =
                        crate::api::wallet::Wallet::init(api_network, api_dbpath, api_descriptor)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_sign_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    network: impl CstDecode<crate::api::types::Network>,
    pset: impl CstDecode<String>,
    mnemonic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_sign_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            let api_pset = pset.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::sign_tx(
                        &api_that,
                        api_network,
                        api_pset,
                        api_mnemonic,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_signed_pset_with_extra_details_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    network: impl CstDecode<crate::api::types::Network>,
    pset: impl CstDecode<String>,
    mnemonic: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_signed_pset_with_extra_details",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            let api_pset = pset.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::signed_pset_with_extra_details(
                        &api_that,
                        api_network,
                        api_pset,
                        api_mnemonic,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_sync_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
    electrum_url: impl CstDecode<String>,
    validate_domain: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_sync",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_validate_domain = validate_domain.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::sync(
                        &api_that,
                        api_electrum_url,
                        api_validate_domain,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_txs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_txs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::txs(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__wallet__wallet_utxos_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::wallet::Wallet>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "wallet_utxos",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::LwkError>((move || {
                    let output_ok = crate::api::wallet::Wallet::utxos(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f32> for f32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f32 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<i64> for i64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i64 {
        self
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Mainnet,
            1 => crate::api::types::Network::Testnet,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for RustOpaqueNom<Mutex<lwk_wollet::Wollet>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_standard = <String>::sse_decode(deserializer);
        let mut var_confidential = <String>::sse_decode(deserializer);
        let mut var_index = <Option<u32>>::sse_decode(deserializer);
        let mut var_blindingKey = <Option<String>>::sse_decode(deserializer);
        return crate::api::types::Address {
            standard: var_standard,
            confidential: var_confidential,
            index: var_index,
            blinding_key: var_blindingKey,
        };
    }
}

impl SseDecode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_assetId = <String>::sse_decode(deserializer);
        let mut var_value = <i64>::sse_decode(deserializer);
        return crate::api::types::Balance {
            asset_id: var_assetId,
            value: var_value,
        };
    }
}

impl SseDecode for crate::api::blockchain::Blockchain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::blockchain::Blockchain {};
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::descriptor::Descriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ctDescriptor = <String>::sse_decode(deserializer);
        return crate::api::descriptor::Descriptor {
            ct_descriptor: var_ctDescriptor,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::types::Balance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::Balance>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::Tx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::Tx>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::error::LwkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msg = <String>::sse_decode(deserializer);
        return crate::api::error::LwkError { msg: var_msg };
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Mainnet,
            1 => crate::api::types::Network::Testnet,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::PayjoinTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pset = <String>::sse_decode(deserializer);
        let mut var_networkFee = <u64>::sse_decode(deserializer);
        let mut var_assetFee = <u64>::sse_decode(deserializer);
        return crate::api::types::PayjoinTx {
            pset: var_pset,
            network_fee: var_networkFee,
            asset_fee: var_assetFee,
        };
    }
}

impl SseDecode for crate::api::types::PsetAmounts {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_absoluteFees = <u64>::sse_decode(deserializer);
        let mut var_balances = <Vec<crate::api::types::Balance>>::sse_decode(deserializer);
        return crate::api::types::PsetAmounts {
            absolute_fees: var_absoluteFees,
            balances: var_balances,
        };
    }
}

impl SseDecode for crate::api::types::Tx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_timestamp = <Option<u32>>::sse_decode(deserializer);
        let mut var_kind = <String>::sse_decode(deserializer);
        let mut var_balances = <Vec<crate::api::types::Balance>>::sse_decode(deserializer);
        let mut var_txid = <String>::sse_decode(deserializer);
        let mut var_outputs = <Vec<crate::api::types::TxOut>>::sse_decode(deserializer);
        let mut var_inputs = <Vec<crate::api::types::TxOut>>::sse_decode(deserializer);
        let mut var_fee = <u64>::sse_decode(deserializer);
        let mut var_height = <Option<u32>>::sse_decode(deserializer);
        let mut var_unblindedUrl = <String>::sse_decode(deserializer);
        let mut var_vsize = <usize>::sse_decode(deserializer);
        return crate::api::types::Tx {
            timestamp: var_timestamp,
            kind: var_kind,
            balances: var_balances,
            txid: var_txid,
            outputs: var_outputs,
            inputs: var_inputs,
            fee: var_fee,
            height: var_height,
            unblinded_url: var_unblindedUrl,
            vsize: var_vsize,
        };
    }
}

impl SseDecode for crate::api::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_scriptPubkey = <String>::sse_decode(deserializer);
        let mut var_outpoint = <crate::api::types::OutPoint>::sse_decode(deserializer);
        let mut var_height = <Option<u32>>::sse_decode(deserializer);
        let mut var_unblinded = <crate::api::types::TxOutSecrets>::sse_decode(deserializer);
        let mut var_isSpent = <bool>::sse_decode(deserializer);
        let mut var_address = <crate::api::types::Address>::sse_decode(deserializer);
        return crate::api::types::TxOut {
            script_pubkey: var_scriptPubkey,
            outpoint: var_outpoint,
            height: var_height,
            unblinded: var_unblinded,
            is_spent: var_isSpent,
            address: var_address,
        };
    }
}

impl SseDecode for crate::api::types::TxOutSecrets {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_valueBf = <String>::sse_decode(deserializer);
        let mut var_asset = <String>::sse_decode(deserializer);
        let mut var_assetBf = <String>::sse_decode(deserializer);
        return crate::api::types::TxOutSecrets {
            value: var_value,
            value_bf: var_valueBf,
            asset: var_asset,
            asset_bf: var_assetBf,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::wallet::Wallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <RustOpaqueNom<Mutex<lwk_wollet::Wollet>>>::sse_decode(deserializer);
        return crate::api::wallet::Wallet { inner: var_inner };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Address {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.standard.into_into_dart().into_dart(),
            self.confidential.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Address {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Address> for crate::api::types::Address {
    fn into_into_dart(self) -> crate::api::types::Address {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Balance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.asset_id.into_into_dart().into_dart(),
            self.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Balance {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Balance> for crate::api::types::Balance {
    fn into_into_dart(self) -> crate::api::types::Balance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::blockchain::Blockchain {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::blockchain::Blockchain
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::blockchain::Blockchain>
    for crate::api::blockchain::Blockchain
{
    fn into_into_dart(self) -> crate::api::blockchain::Blockchain {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::descriptor::Descriptor {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.ct_descriptor.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::descriptor::Descriptor
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::descriptor::Descriptor>
    for crate::api::descriptor::Descriptor
{
    fn into_into_dart(self) -> crate::api::descriptor::Descriptor {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::LwkError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.msg.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::LwkError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::LwkError>
    for crate::api::error::LwkError
{
    fn into_into_dart(self) -> crate::api::error::LwkError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Mainnet => 0.into_dart(),
            Self::Testnet => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PayjoinTx {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pset.into_into_dart().into_dart(),
            self.network_fee.into_into_dart().into_dart(),
            self.asset_fee.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PayjoinTx {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PayjoinTx>
    for crate::api::types::PayjoinTx
{
    fn into_into_dart(self) -> crate::api::types::PayjoinTx {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PsetAmounts {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.absolute_fees.into_into_dart().into_dart(),
            self.balances.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PsetAmounts
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PsetAmounts>
    for crate::api::types::PsetAmounts
{
    fn into_into_dart(self) -> crate::api::types::PsetAmounts {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Tx {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.timestamp.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.balances.into_into_dart().into_dart(),
            self.txid.into_into_dart().into_dart(),
            self.outputs.into_into_dart().into_dart(),
            self.inputs.into_into_dart().into_dart(),
            self.fee.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.unblinded_url.into_into_dart().into_dart(),
            self.vsize.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Tx {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Tx> for crate::api::types::Tx {
    fn into_into_dart(self) -> crate::api::types::Tx {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::TxOut {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.script_pubkey.into_into_dart().into_dart(),
            self.outpoint.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.unblinded.into_into_dart().into_dart(),
            self.is_spent.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::TxOut {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::TxOut> for crate::api::types::TxOut {
    fn into_into_dart(self) -> crate::api::types::TxOut {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::TxOutSecrets {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.value_bf.into_into_dart().into_dart(),
            self.asset.into_into_dart().into_dart(),
            self.asset_bf.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::TxOutSecrets
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::TxOutSecrets>
    for crate::api::types::TxOutSecrets
{
    fn into_into_dart(self) -> crate::api::types::TxOutSecrets {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::wallet::Wallet {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::wallet::Wallet {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::wallet::Wallet> for crate::api::wallet::Wallet {
    fn into_into_dart(self) -> crate::api::wallet::Wallet {
        self
    }
}

impl SseEncode for RustOpaqueNom<Mutex<lwk_wollet::Wollet>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.standard, serializer);
        <String>::sse_encode(self.confidential, serializer);
        <Option<u32>>::sse_encode(self.index, serializer);
        <Option<String>>::sse_encode(self.blinding_key, serializer);
    }
}

impl SseEncode for crate::api::types::Balance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.asset_id, serializer);
        <i64>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for crate::api::blockchain::Blockchain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::descriptor::Descriptor {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.ct_descriptor, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::types::Balance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::Balance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::Tx> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::Tx>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::error::LwkError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.msg, serializer);
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Mainnet => 0,
                crate::api::types::Network::Testnet => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::PayjoinTx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pset, serializer);
        <u64>::sse_encode(self.network_fee, serializer);
        <u64>::sse_encode(self.asset_fee, serializer);
    }
}

impl SseEncode for crate::api::types::PsetAmounts {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.absolute_fees, serializer);
        <Vec<crate::api::types::Balance>>::sse_encode(self.balances, serializer);
    }
}

impl SseEncode for crate::api::types::Tx {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u32>>::sse_encode(self.timestamp, serializer);
        <String>::sse_encode(self.kind, serializer);
        <Vec<crate::api::types::Balance>>::sse_encode(self.balances, serializer);
        <String>::sse_encode(self.txid, serializer);
        <Vec<crate::api::types::TxOut>>::sse_encode(self.outputs, serializer);
        <Vec<crate::api::types::TxOut>>::sse_encode(self.inputs, serializer);
        <u64>::sse_encode(self.fee, serializer);
        <Option<u32>>::sse_encode(self.height, serializer);
        <String>::sse_encode(self.unblinded_url, serializer);
        <usize>::sse_encode(self.vsize, serializer);
    }
}

impl SseEncode for crate::api::types::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.script_pubkey, serializer);
        <crate::api::types::OutPoint>::sse_encode(self.outpoint, serializer);
        <Option<u32>>::sse_encode(self.height, serializer);
        <crate::api::types::TxOutSecrets>::sse_encode(self.unblinded, serializer);
        <bool>::sse_encode(self.is_spent, serializer);
        <crate::api::types::Address>::sse_encode(self.address, serializer);
    }
}

impl SseEncode for crate::api::types::TxOutSecrets {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.value_bf, serializer);
        <String>::sse_encode(self.asset, serializer);
        <String>::sse_encode(self.asset_bf, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::wallet::Wallet {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<Mutex<lwk_wollet::Wollet>>>::sse_encode(self.inner, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use crate::api::wallet::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<RustOpaqueNom<Mutex<lwk_wollet::Wollet>>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<Mutex<lwk_wollet::Wollet>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::types::Address> for wire_cst_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Address {
            crate::api::types::Address {
                standard: self.standard.cst_decode(),
                confidential: self.confidential.cst_decode(),
                index: self.index.cst_decode(),
                blinding_key: self.blinding_key.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Balance> for wire_cst_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Balance {
            crate::api::types::Balance {
                asset_id: self.asset_id.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::Blockchain> for wire_cst_blockchain {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::Blockchain {
            crate::api::blockchain::Blockchain {}
        }
    }
    impl CstDecode<crate::api::blockchain::Blockchain> for *mut wire_cst_blockchain {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::Blockchain {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::blockchain::Blockchain>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::descriptor::Descriptor> for *mut wire_cst_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::Descriptor {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::descriptor::Descriptor>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::wallet::Wallet> for *mut wire_cst_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::Wallet {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::wallet::Wallet>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::descriptor::Descriptor> for wire_cst_descriptor {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::Descriptor {
            crate::api::descriptor::Descriptor {
                ct_descriptor: self.ct_descriptor.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::Balance>> for *mut wire_cst_list_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::Balance> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::Tx>> for *mut wire_cst_list_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::Tx> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::TxOut>> for *mut wire_cst_list_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::TxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::api::error::LwkError> for wire_cst_lwk_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::LwkError {
            crate::api::error::LwkError {
                msg: self.msg.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            crate::api::types::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PayjoinTx> for wire_cst_payjoin_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PayjoinTx {
            crate::api::types::PayjoinTx {
                pset: self.pset.cst_decode(),
                network_fee: self.network_fee.cst_decode(),
                asset_fee: self.asset_fee.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PsetAmounts> for wire_cst_pset_amounts {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PsetAmounts {
            crate::api::types::PsetAmounts {
                absolute_fees: self.absolute_fees.cst_decode(),
                balances: self.balances.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Tx> for wire_cst_tx {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Tx {
            crate::api::types::Tx {
                timestamp: self.timestamp.cst_decode(),
                kind: self.kind.cst_decode(),
                balances: self.balances.cst_decode(),
                txid: self.txid.cst_decode(),
                outputs: self.outputs.cst_decode(),
                inputs: self.inputs.cst_decode(),
                fee: self.fee.cst_decode(),
                height: self.height.cst_decode(),
                unblinded_url: self.unblinded_url.cst_decode(),
                vsize: self.vsize.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxOut> for wire_cst_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxOut {
            crate::api::types::TxOut {
                script_pubkey: self.script_pubkey.cst_decode(),
                outpoint: self.outpoint.cst_decode(),
                height: self.height.cst_decode(),
                unblinded: self.unblinded.cst_decode(),
                is_spent: self.is_spent.cst_decode(),
                address: self.address.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxOutSecrets> for wire_cst_tx_out_secrets {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxOutSecrets {
            crate::api::types::TxOutSecrets {
                value: self.value.cst_decode(),
                value_bf: self.value_bf.cst_decode(),
                asset: self.asset.cst_decode(),
                asset_bf: self.asset_bf.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::wallet::Wallet> for wire_cst_wallet {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::Wallet {
            crate::api::wallet::Wallet {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_address {
        fn new_with_null_ptr() -> Self {
            Self {
                standard: core::ptr::null_mut(),
                confidential: core::ptr::null_mut(),
                index: core::ptr::null_mut(),
                blinding_key: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_address {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                asset_id: core::ptr::null_mut(),
                value: Default::default(),
            }
        }
    }
    impl Default for wire_cst_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_blockchain {
        fn new_with_null_ptr() -> Self {
            Self {}
        }
    }
    impl Default for wire_cst_blockchain {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_descriptor {
        fn new_with_null_ptr() -> Self {
            Self {
                ct_descriptor: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_descriptor {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lwk_error {
        fn new_with_null_ptr() -> Self {
            Self {
                msg: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lwk_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: core::ptr::null_mut(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payjoin_tx {
        fn new_with_null_ptr() -> Self {
            Self {
                pset: core::ptr::null_mut(),
                network_fee: Default::default(),
                asset_fee: Default::default(),
            }
        }
    }
    impl Default for wire_cst_payjoin_tx {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pset_amounts {
        fn new_with_null_ptr() -> Self {
            Self {
                absolute_fees: Default::default(),
                balances: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_pset_amounts {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx {
        fn new_with_null_ptr() -> Self {
            Self {
                timestamp: core::ptr::null_mut(),
                kind: core::ptr::null_mut(),
                balances: core::ptr::null_mut(),
                txid: core::ptr::null_mut(),
                outputs: core::ptr::null_mut(),
                inputs: core::ptr::null_mut(),
                fee: Default::default(),
                height: core::ptr::null_mut(),
                unblinded_url: core::ptr::null_mut(),
                vsize: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                script_pubkey: core::ptr::null_mut(),
                outpoint: Default::default(),
                height: core::ptr::null_mut(),
                unblinded: Default::default(),
                is_spent: Default::default(),
                address: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out_secrets {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                value_bf: core::ptr::null_mut(),
                asset: core::ptr::null_mut(),
                asset_bf: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_tx_out_secrets {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_wallet {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: Default::default(),
            }
        }
    }
    impl Default for wire_cst_wallet {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__types__address_address_from_script(
        port_: i64,
        network: i32,
        script: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__address_address_from_script_impl(
            port_,
            network,
            script,
            blinding_key,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__types__address_validate(
        port_: i64,
        address_string: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__address_validate_impl(port_, address_string)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__blockchain__blockchain_test(
        port_: i64,
        that: *mut wire_cst_blockchain,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__blockchain__blockchain_test_impl(port_, that, electrum_url)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__blockchain__broadcast_signed_pset(
        port_: i64,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        signed_pset: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__blockchain__broadcast_signed_pset_impl(port_, electrum_url, signed_pset)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__blockchain__broadcast_tx_bytes(
        port_: i64,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        tx_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__blockchain__broadcast_tx_bytes_impl(port_, electrum_url, tx_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__descriptor__descriptor_new_confidential(
        port_: i64,
        network: i32,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__descriptor__descriptor_new_confidential_impl(port_, network, mnemonic)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__transaction__extract_tx_bytes(
        port_: i64,
        pset: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__transaction__extract_tx_bytes_impl(port_, pset)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_address(
        port_: i64,
        that: *mut wire_cst_wallet,
        index: u32,
    ) {
        wire__crate__api__wallet__wallet_address_impl(port_, that, index)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_address_last_unused(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_address_last_unused_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_balances(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_balances_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_blinding_key(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_blinding_key_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_build_asset_tx(
        port_: i64,
        that: *mut wire_cst_wallet,
        sats: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        fee_rate: f32,
        asset: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__wallet__wallet_build_asset_tx_impl(
            port_,
            that,
            sats,
            out_address,
            fee_rate,
            asset,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_build_lbtc_tx(
        port_: i64,
        that: *mut wire_cst_wallet,
        sats: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        fee_rate: f32,
        drain: bool,
    ) {
        wire__crate__api__wallet__wallet_build_lbtc_tx_impl(
            port_,
            that,
            sats,
            out_address,
            fee_rate,
            drain,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_build_payjoin_tx(
        port_: i64,
        that: *mut wire_cst_wallet,
        sats: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        asset: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) {
        wire__crate__api__wallet__wallet_build_payjoin_tx_impl(
            port_,
            that,
            sats,
            out_address,
            asset,
            network,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_decode_tx(
        port_: i64,
        that: *mut wire_cst_wallet,
        pset: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__wallet__wallet_decode_tx_impl(port_, that, pset)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_descriptor(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_descriptor_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_init(
        port_: i64,
        network: i32,
        dbpath: *mut wire_cst_list_prim_u_8_strict,
        descriptor: *mut wire_cst_descriptor,
    ) {
        wire__crate__api__wallet__wallet_init_impl(port_, network, dbpath, descriptor)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_sign_tx(
        port_: i64,
        that: *mut wire_cst_wallet,
        network: i32,
        pset: *mut wire_cst_list_prim_u_8_strict,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__wallet__wallet_sign_tx_impl(port_, that, network, pset, mnemonic)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_signed_pset_with_extra_details(
        port_: i64,
        that: *mut wire_cst_wallet,
        network: i32,
        pset: *mut wire_cst_list_prim_u_8_strict,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__wallet__wallet_signed_pset_with_extra_details_impl(
            port_, that, network, pset, mnemonic,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_sync(
        port_: i64,
        that: *mut wire_cst_wallet,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        validate_domain: bool,
    ) {
        wire__crate__api__wallet__wallet_sync_impl(port_, that, electrum_url, validate_domain)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_txs(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_txs_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_wire__crate__api__wallet__wallet_utxos(
        port_: i64,
        that: *mut wire_cst_wallet,
    ) {
        wire__crate__api__wallet__wallet_utxos_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_rust_arc_increment_strong_count_RustOpaque_Mutexlwk_wolletWollet(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<Mutex<lwk_wollet::Wollet>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_rust_arc_decrement_strong_count_RustOpaque_Mutexlwk_wolletWollet(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<Mutex<lwk_wollet::Wollet>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_box_autoadd_blockchain() -> *mut wire_cst_blockchain {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_blockchain::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_box_autoadd_descriptor() -> *mut wire_cst_descriptor {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_descriptor::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_box_autoadd_wallet() -> *mut wire_cst_wallet {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_wallet::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_list_balance(len: i32) -> *mut wire_cst_list_balance {
        let wrap = wire_cst_list_balance {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_balance>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_list_tx(len: i32) -> *mut wire_cst_list_tx {
        let wrap = wire_cst_list_tx {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_lwk_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
        let wrap = wire_cst_list_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address {
        standard: *mut wire_cst_list_prim_u_8_strict,
        confidential: *mut wire_cst_list_prim_u_8_strict,
        index: *mut u32,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance {
        asset_id: *mut wire_cst_list_prim_u_8_strict,
        value: i64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_blockchain {}
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_descriptor {
        ct_descriptor: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_balance {
        ptr: *mut wire_cst_balance,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx {
        ptr: *mut wire_cst_tx,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_out {
        ptr: *mut wire_cst_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lwk_error {
        msg: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: *mut wire_cst_list_prim_u_8_strict,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payjoin_tx {
        pset: *mut wire_cst_list_prim_u_8_strict,
        network_fee: u64,
        asset_fee: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pset_amounts {
        absolute_fees: u64,
        balances: *mut wire_cst_list_balance,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx {
        timestamp: *mut u32,
        kind: *mut wire_cst_list_prim_u_8_strict,
        balances: *mut wire_cst_list_balance,
        txid: *mut wire_cst_list_prim_u_8_strict,
        outputs: *mut wire_cst_list_tx_out,
        inputs: *mut wire_cst_list_tx_out,
        fee: u64,
        height: *mut u32,
        unblinded_url: *mut wire_cst_list_prim_u_8_strict,
        vsize: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out {
        script_pubkey: *mut wire_cst_list_prim_u_8_strict,
        outpoint: wire_cst_out_point,
        height: *mut u32,
        unblinded: wire_cst_tx_out_secrets,
        is_spent: bool,
        address: wire_cst_address,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out_secrets {
        value: u64,
        value_bf: *mut wire_cst_list_prim_u_8_strict,
        asset: *mut wire_cst_list_prim_u_8_strict,
        asset_bf: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_wallet {
        inner: usize,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use crate::api::wallet::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::api::types::Address>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Address {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::types::Address {
                standard: self_.get(0).cst_decode(),
                confidential: self_.get(1).cst_decode(),
                index: self_.get(2).cst_decode(),
                blinding_key: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Balance>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Balance {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::types::Balance {
                asset_id: self_.get(0).cst_decode(),
                value: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::blockchain::Blockchain>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::blockchain::Blockchain {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                0,
                "Expected 0 elements, got {}",
                self_.length()
            );
            crate::api::blockchain::Blockchain {}
        }
    }
    impl CstDecode<crate::api::descriptor::Descriptor>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::descriptor::Descriptor {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            crate::api::descriptor::Descriptor {
                ct_descriptor: self_.get(0).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::Balance>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::Balance> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<Vec<crate::api::types::Tx>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::Tx> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::TxOut>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::TxOut> {
            self.dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap()
                .iter()
                .map(CstDecode::cst_decode)
                .collect()
        }
    }
    impl CstDecode<crate::api::error::LwkError>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::LwkError {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            crate::api::error::LwkError {
                msg: self_.get(0).cst_decode(),
            }
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<crate::api::types::OutPoint>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::types::OutPoint {
                txid: self_.get(0).cst_decode(),
                vout: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PayjoinTx>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PayjoinTx {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::api::types::PayjoinTx {
                pset: self_.get(0).cst_decode(),
                network_fee: self_.get(1).cst_decode(),
                asset_fee: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PsetAmounts>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PsetAmounts {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::types::PsetAmounts {
                absolute_fees: self_.get(0).cst_decode(),
                balances: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Tx>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Tx {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                10,
                "Expected 10 elements, got {}",
                self_.length()
            );
            crate::api::types::Tx {
                timestamp: self_.get(0).cst_decode(),
                kind: self_.get(1).cst_decode(),
                balances: self_.get(2).cst_decode(),
                txid: self_.get(3).cst_decode(),
                outputs: self_.get(4).cst_decode(),
                inputs: self_.get(5).cst_decode(),
                fee: self_.get(6).cst_decode(),
                height: self_.get(7).cst_decode(),
                unblinded_url: self_.get(8).cst_decode(),
                vsize: self_.get(9).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxOut>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxOut {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                6,
                "Expected 6 elements, got {}",
                self_.length()
            );
            crate::api::types::TxOut {
                script_pubkey: self_.get(0).cst_decode(),
                outpoint: self_.get(1).cst_decode(),
                height: self_.get(2).cst_decode(),
                unblinded: self_.get(3).cst_decode(),
                is_spent: self_.get(4).cst_decode(),
                address: self_.get(5).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxOutSecrets>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxOutSecrets {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::types::TxOutSecrets {
                value: self_.get(0).cst_decode(),
                value_bf: self_.get(1).cst_decode(),
                asset: self_.get(2).cst_decode(),
                asset_bf: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::wallet::Wallet>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::wallet::Wallet {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            crate::api::wallet::Wallet {
                inner: self_.get(0).cst_decode(),
            }
        }
    }
    impl CstDecode<RustOpaqueNom<Mutex<lwk_wollet::Wollet>>>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<Mutex<lwk_wollet::Wollet>> {
            #[cfg(target_pointer_width = "64")]
            {
                compile_error!("64-bit pointers are not supported.");
            }
            unsafe { decode_rust_opaque_nom((self.as_f64().unwrap() as usize) as _) }
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<f32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i64 {
            ::std::convert::TryInto::<i64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<crate::api::types::Network>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Network {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__address_address_from_script(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        network: i32,
        script: String,
        blinding_key: Option<String>,
    ) {
        wire__crate__api__types__address_address_from_script_impl(
            port_,
            network,
            script,
            blinding_key,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__address_validate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        address_string: String,
    ) {
        wire__crate__api__types__address_validate_impl(port_, address_string)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__blockchain__blockchain_test(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        electrum_url: String,
    ) {
        wire__crate__api__blockchain__blockchain_test_impl(port_, that, electrum_url)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__blockchain__broadcast_signed_pset(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        electrum_url: String,
        signed_pset: String,
    ) {
        wire__crate__api__blockchain__broadcast_signed_pset_impl(port_, electrum_url, signed_pset)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__blockchain__broadcast_tx_bytes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        electrum_url: String,
        tx_bytes: Box<[u8]>,
    ) {
        wire__crate__api__blockchain__broadcast_tx_bytes_impl(port_, electrum_url, tx_bytes)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__descriptor__descriptor_new_confidential(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        network: i32,
        mnemonic: String,
    ) {
        wire__crate__api__descriptor__descriptor_new_confidential_impl(port_, network, mnemonic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__transaction__extract_tx_bytes(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        pset: String,
    ) {
        wire__crate__api__transaction__extract_tx_bytes_impl(port_, pset)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_address(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        index: u32,
    ) {
        wire__crate__api__wallet__wallet_address_impl(port_, that, index)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_address_last_unused(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_address_last_unused_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_balances(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_balances_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_blinding_key(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_blinding_key_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_build_asset_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        sats: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        fee_rate: f32,
        asset: String,
    ) {
        wire__crate__api__wallet__wallet_build_asset_tx_impl(
            port_,
            that,
            sats,
            out_address,
            fee_rate,
            asset,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_build_lbtc_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        sats: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        fee_rate: f32,
        drain: bool,
    ) {
        wire__crate__api__wallet__wallet_build_lbtc_tx_impl(
            port_,
            that,
            sats,
            out_address,
            fee_rate,
            drain,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_build_payjoin_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        sats: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        asset: String,
        network: i32,
    ) {
        wire__crate__api__wallet__wallet_build_payjoin_tx_impl(
            port_,
            that,
            sats,
            out_address,
            asset,
            network,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_decode_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        pset: String,
    ) {
        wire__crate__api__wallet__wallet_decode_tx_impl(port_, that, pset)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_descriptor(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_descriptor_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_init(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        network: i32,
        dbpath: String,
        descriptor: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_init_impl(port_, network, dbpath, descriptor)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_sign_tx(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        network: i32,
        pset: String,
        mnemonic: String,
    ) {
        wire__crate__api__wallet__wallet_sign_tx_impl(port_, that, network, pset, mnemonic)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_signed_pset_with_extra_details(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        network: i32,
        pset: String,
        mnemonic: String,
    ) {
        wire__crate__api__wallet__wallet_signed_pset_with_extra_details_impl(
            port_, that, network, pset, mnemonic,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_sync(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        electrum_url: String,
        validate_domain: bool,
    ) {
        wire__crate__api__wallet__wallet_sync_impl(port_, that, electrum_url, validate_domain)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_txs(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_txs_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__wallet__wallet_utxos(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__wallet__wallet_utxos_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_Mutexlwk_wolletWollet(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<Mutex<lwk_wollet::Wollet>>::increment_strong_count(ptr as _);
        }
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_Mutexlwk_wolletWollet(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<Mutex<lwk_wollet::Wollet>>::decrement_strong_count(ptr as _);
        }
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
